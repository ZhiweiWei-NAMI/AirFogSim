import traci
import numpy as np
import random
class TrafficManager():
    """The traffic manager class. It manages both vehicle traffic and UAV traffic. It also manipulates the positions of the vehicles, UAVs, RSUs, and cloud servers.
    """

    def __init__(self, config_traffic, traci_connection:traci.connection):
        """Initialize the traffic manager.

        Args:
            config_traffic (dict): The traffic configuration part of the environment configuration.
        """
        self._config_traffic = config_traffic
        self._max_n_vehicles = config_traffic.get("max_n_vehicles", 100)
        self._x_range = config_traffic.get("x_range", [0, 1000])
        self._y_range = config_traffic.get("y_range", [0, 1000])
        self._UAV_z_range = config_traffic.get("UAV_z_range", [50, 300])
        self._max_n_UAVs = config_traffic.get("max_n_UAVs", 10)
        self._RSU_positions = config_traffic.get("RSU_positions", [])
        self._max_n_cloudServers = config_traffic.get("max_n_cloudServers", 1)
        self._arrival_lambda = config_traffic.get("arrival_lambda", 1)
        self._traci_connection = traci_connection
        self._vehicle_infos = {} # use vehicle_id -> {position, speed, routeId}
        self._UAV_infos = {} # uav_id -> {position, speed, acceleration, angle, phi}
        self._RSU_infos = {}
        self._cloudServer_infos = {}
        self._sumo_route_ids = [] # all route ids in SUMO, further information can be gained by traci_connection.route.getEdges(route_id)
        self._sumo_edges = {} # each edge is a series of lanes in SUMO, edgeId -> [laneId1, laneId2, ...]
        self._sumo_laneIds = [] # all lane ids in SUMO
        self._traffic_interval = traci_connection.simulation.getDeltaT()
        self._vehicle_id_counter = 0
        self._UAV_id_counter = 0
        self._RSU_id_counter = 0
        self._cloudServer_id_counter = 0
        self._route_id_counter = 0
        self._initialize_edges_and_lanes()
        self._update_route_ids()
        self._initialize_RSUs()
        self._initialize_cloudServers()
        self._initialize_UAVs()

    def getRSUPositions(self):
        """Get the RSU positions.

        Returns:
            list: The RSU positions.
        """
        return self._RSU_positions

    def getNumberOfRSUs(self):
        """Get the number of RSUs.

        Returns:
            int: The number of RSUs.
        """
        return len(self._RSU_infos)
    
    def getNumberOfCloudServers(self):
        """Get the number of cloud servers.

        Returns:
            int: The number of cloud servers.
        """
        return len(self._cloudServer_infos)
    
    def getNumberOfUAVs(self):
        """Get the number of UAVs.

        Returns:
            int: The number of UAVs.
        """
        return len(self._UAV_infos)
    
    def getNumberOfVehicles(self):
        """Get the number of vehicles.

        Returns:
            int: The number of vehicles.
        """
        return len(self._vehicle_infos)

    def _initialize_RSUs(self):
        """Initialize the RSU information.
        """
        for RSU_position in self._RSU_positions:
            RSU_id = "RSU_" + str(self._RSU_id_counter)
            self._RSU_id_counter += 1
            self._RSU_infos[RSU_id] = {"position": RSU_position, "id": RSU_id}

    def _initialize_cloudServers(self):
        """Initialize the cloud server information.
        """
        for _ in range(self._max_n_cloudServers):
            cloudServer_id = "cloudServer_" + str(self._RSU_id_counter)
            self._cloudServer_id_counter += 1
            self._cloudServer_infos[cloudServer_id] = {"position": (0, 0, 0), "id": cloudServer_id}

    def _initialize_UAVs(self):
        """Initialize the UAV information with random positions in the given range.
        """
        for _ in range(self._max_n_UAVs):
            UAV_id = "UAV_" + str(self._UAV_id_counter)
            self._UAV_id_counter += 1
            position = (random.uniform(self._x_range[0], self._x_range[1]), random.uniform(self._y_range[0], self._y_range[1]), random.uniform(self._UAV_z_range[0], self._UAV_z_range[1]))
            self._UAV_infos[UAV_id] = {"position": position}

    def _initialize_edges_and_lanes(self):
        """Initialize the edges information.
        """
        lane_ids = self._traci_connection.lane.getIDList()
        for lane_id in lane_ids:
            edge_id = self._traci_connection.lane.getEdgeID(lane_id)
            if edge_id not in self._sumo_edges:
                self._sumo_edges[edge_id] = []
            self._sumo_edges[edge_id].append(lane_id)
            self._sumo_laneIds.append(lane_id)
        edge_ids = self._traci_connection.edge.getIDList()
        for edge_id in edge_ids:
            if edge_id not in self._sumo_edges:
                self._sumo_edges[edge_id] = []

    def _update_route_ids(self):
        """Update the route information generated by SUMO.
        """
        route_ids = self._traci_connection.route.getIDList()
        self._sumo_route_ids = route_ids

    def _generateRandomRoute(self):
        """Generate a random route id.

        Returns:
            str: The route id.
        """
        route_id = "gen_veh_route_" + str(self._route_id_counter)
        edges = list(self._sumo_edges.keys())
        while True:
            try:
                from_edge, to_edge = random.sample(edges, 2)
                route = self._traci_connection.simulation.findRoute(from_edge, to_edge)
                while len(route.edges) == 0:
                    from_edge, to_edge = random.sample(edges, 2)
                    route = self._traci_connection.simulation.findRoute(from_edge, to_edge)
                self._traci_connection.route.add(route_id, route.edges)
                break
            except:
                pass
            
        self._route_id_counter += 1
        return route_id
    
    def updateVehicleMobilityPatterns(self, vehicle_mobility_patterns):
        """Update the vehicle mobility patterns.

        Args:
            vehicle_mobility_patterns (dict): The vehicle mobility patterns. The key is vehicle id, and the value is the mobility pattern={angle, speed}
        """
        for vehicle_id, mobility_pattern in vehicle_mobility_patterns.items():
            self._traci_connection.vehicle.setSpeed(vehicle_id, mobility_pattern["speed"])

    def updateUAVMobilityPatterns(self, UAV_mobility_patterns):
        """Update the UAV mobility patterns.

        Args:
            UAV_mobility_patterns (dict): The UAV mobility patterns. The key is UAV id, and the value is the mobility pattern={angle, phi, speed}
        """
        for UAV_id, mobility_pattern in UAV_mobility_patterns.items():
            assert UAV_id in self._UAV_infos, "The UAV id should be in the UAV information."
            # UAV is controlled by the python
            self._UAV_infos[UAV_id]["speed"] = mobility_pattern["speed"]
            self._UAV_infos[UAV_id]["angle"] = mobility_pattern["angle"]
            self._UAV_infos[UAV_id]["phi"] = mobility_pattern["phi"]

    def stepSimulation(self):
        """Step the simulation for one step. Generate vehicles according to Poisson distribution, limit the number of vehicles, and update the route ids.
        """
        to_generate_vehicles = int(np.random.poisson(self._arrival_lambda*self._traffic_interval))
        current_n_vehicles = self._traci_connection.vehicle.getIDCount()
        to_generate_vehicles = max(min(to_generate_vehicles, self._max_n_vehicles - current_n_vehicles), 0)
        for _ in range(to_generate_vehicles):
            vehicle_id = "vehicle_" + str(self._vehicle_id_counter)
            self._vehicle_id_counter += 1
            route_id = self._generateRandomRoute()
            self._traci_connection.vehicle.add(vehicle_id, route_id)
        self._traci_connection.simulationStep()
        vehicle_ids = self._traci_connection.vehicle.getIDList()
        self._vehicle_infos = {}
        for vehicle_id in vehicle_ids:
            position = self._traci_connection.vehicle.getPosition(vehicle_id)
            speed = self._traci_connection.vehicle.getSpeed(vehicle_id)
            route_id = self._traci_connection.vehicle.getRouteID(vehicle_id)
            acceleration = self._traci_connection.vehicle.getAcceleration(vehicle_id)
            angle = self._traci_connection.vehicle.getAngle(vehicle_id)
            position3d = (position[0], position[1], 0)
            self._vehicle_infos[vehicle_id] = {"position": position3d, "speed": speed, "acceleration": acceleration, "angle": angle, "routeId": route_id, 'id': vehicle_id}
        for UAV_id in self._UAV_infos:
            org_position = self._UAV_infos[UAV_id]["position"]
            speed = self._UAV_infos[UAV_id].get("speed", 0)
            last_speed = self._UAV_infos[UAV_id].get("last_speed", 0)
            acceleration = (last_speed - speed) / self._traffic_interval
            self._UAV_infos[UAV_id]["acceleration"] = acceleration
            self._UAV_infos[UAV_id]["last_speed"] = self._UAV_infos[UAV_id].get("speed", 0)
            angle = self._UAV_infos[UAV_id].get("angle", 0)
            phi = self._UAV_infos[UAV_id].get("phi", 0)
            new_position = (org_position[0] + speed * np.cos(angle) * np.cos(phi) * self._traffic_interval, org_position[1] + speed * np.sin(angle) * np.cos(phi) * self._traffic_interval, org_position[2] + speed * np.sin(phi) * self._traffic_interval)
            self._UAV_infos[UAV_id]["position"] = new_position
            self._UAV_infos[UAV_id] = {"position": new_position, "speed": speed, "last_speed": speed, "angle": angle, "phi": phi, "acceleration": acceleration}
        self._update_route_ids()

    def getVehicleTrafficInfos(self):
        """Get the vehicle traffics at the given simulation time.

        Returns:
            dict: The vehicle traffics, including the vehicle id, position, speed, angle, acceleration, and current routeId.
        """
        return self._vehicle_infos
    
    def getUAVTrafficInfos(self):
        """Get the UAV traffics at the given simulation time. The trajectory of the UAVs is controlled by their missions

        Returns:
            dict: The UAV traffics, including the UAV id, position, acceleration, speed, angle, and phi.
        """
        return self._UAV_infos
    
    def getRSUInfos(self):
        """Get the RSU information.

        Returns:
            dict: The RSU information, including the RSU id and position
        """
        return self._RSU_infos
    
    def getCloudServerInfos(self):
        """Get the cloud server information.

        Returns:
            dict: The cloud server information, including the cloud server id and position.
        """
        return self._cloudServer_infos
    
    def getCurrentTime(self):
        """Get the current simulation time.

        Returns:
            float: The current simulation time (in seconds).
        """
        return self._traci_connection.simulation.getTime()